"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrieveContractBytecode = exports.getEtherscanEndpoint = exports.NetworkProberError = void 0;
const plugins_1 = require("hardhat/plugins");
const pluginContext_1 = require("../pluginContext");
// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#list-of-chain-ids
var NetworkID;
(function (NetworkID) {
    NetworkID[NetworkID["MAINNET"] = 1] = "MAINNET";
    NetworkID[NetworkID["ROPSTEN"] = 3] = "ROPSTEN";
    NetworkID[NetworkID["RINKEBY"] = 4] = "RINKEBY";
    NetworkID[NetworkID["GOERLI"] = 5] = "GOERLI";
    NetworkID[NetworkID["KOVAN"] = 42] = "KOVAN";
})(NetworkID || (NetworkID = {}));
const networkIDtoEndpoint = {
    [NetworkID.MAINNET]: "https://api.etherscan.io/api",
    [NetworkID.ROPSTEN]: "https://api-ropsten.etherscan.io/api",
    [NetworkID.RINKEBY]: "https://api-rinkeby.etherscan.io/api",
    [NetworkID.GOERLI]: "https://api-goerli.etherscan.io/api",
    [NetworkID.KOVAN]: "https://api-kovan.etherscan.io/api",
};
class NetworkProberError extends plugins_1.HardhatPluginError {
    constructor(message) {
        super(pluginContext_1.pluginName, message);
    }
}
exports.NetworkProberError = NetworkProberError;
async function getEtherscanEndpoint(provider) {
    const chainID = parseInt(await provider.send("eth_chainId"), 16);
    const endpoint = networkIDtoEndpoint[chainID];
    if (endpoint !== null && endpoint !== undefined) {
        // Beware: this delays URL validation until it is effectively "used".
        // Tests should take this into account.
        return new URL(endpoint);
    }
    throw new NetworkProberError(`An etherscan endpoint could not be found for this network. ChainID: ${chainID}`);
}
exports.getEtherscanEndpoint = getEtherscanEndpoint;
async function retrieveContractBytecode(address, provider) {
    const bytecodeString = (await provider.send("eth_getCode", [
        address,
        "latest",
    ]));
    const deployedBytecode = bytecodeString.startsWith("0x")
        ? bytecodeString.slice(2)
        : bytecodeString;
    if (deployedBytecode.length === 0) {
        return null;
    }
    return deployedBytecode;
}
exports.retrieveContractBytecode = retrieveContractBytecode;
//# sourceMappingURL=prober.js.map